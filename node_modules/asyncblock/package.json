{
  "name": "asyncblock",
  "version": "2.1.13",
  "description": "A simple and powerful abstraction of node-fibers",
  "keywords": [
    "fiber",
    "fibers",
    "coroutine",
    "stop",
    "go",
    "green",
    "red"
  ],
  "homepage": "https://github.com/scriby/asyncblock",
  "author": {
    "name": "Chris Scribner"
  },
  "main": "asyncblock",
  "repository": {
    "type": "git",
    "url": "git://github.com/scriby/asyncblock.git"
  },
  "dependencies": {
    "fibers": "1.0.0",
    "uglify-js_scriby": "https://github.com/scriby/UglifyJS/tarball/1.2.5-6"
  },
  "devDependencies": {
    "vows": "0.7.0",
    "jshint": "0.5.9"
  },
  "readme": "```\n                                        ______  ______              ______  \n______ ______________  _________ __________  /_ ___  /______ __________  /__\n_  __ `/__  ___/__  / / /__  __ \\_  ___/__  __ \\__  / _  __ \\_  ___/__  //_/\n/ /_/ / _(__  ) _  /_/ / _  / / // /__  _  /_/ /_  /  / /_/ // /__  _  ,<   \n\\__,_/  /____/  _\\__, /  /_/ /_/ \\___/  /_.___/ /_/   \\____/ \\___/  /_/|_|  \n                /____/                                                      \n\n```\n==================================================================\n\nA fully fledged flow control library built on top of fibers.\n\n###Installation\n\n```javascript\nnpm install asyncblock\n```\n\nSee [node-fibers](https://github.com/laverdet/node-fibers) for more information on fibers\n\n### Why should I use asyncblock?\n\n* Write async code in synchronous style without blocking the event loop\n* Effortlessly combine serial and parallel operations with minimal boilerplate\n* Produce code which is easier to read, reason about, and modify\n    * Compared to flow control libraries, asyncblock makes it easy to share data between async steps. There's no need to create variables in an outer scope or use \"waterfall\".\n* Simplify error handling practices\n    * If an error occurs in an async step, automatically call your callback with the error, or throw an Error\n* Improve debugging by not losing stack traces across async calls\n    * Line numbers don't change. What's in the stack trace maps directly to your code (You may lose this with CPS transforms)\n    * If using a debugger, it's easy to step line-by-line through asyncblock code (compared to async libraries)\n\n## Overview\n\nCheck out the [overview](https://github.com/scriby/asyncblock/blob/master/docs/overview.md) to get an at-a-glance overview\nof the different ways asyncblock can be used.\n\n## Examples\n\nA few quick examples to show off the functionality of asyncblock:\n\n### Sleeping in series\n\n```javascript\nasyncblock(function(flow){\n    console.time('time');\n\n    setTimeout(flow.add(), 1000);\n    flow.wait(); //Wait for the first setTimeout to finish\n\n    setTimeout(flow.add(), 2000);\n    flow.wait(); //Wait for the second setTimeout to finish\n\n    console.timeEnd('time'); //3 seconds\n});\n```\n\n### Sleeping in parallel\n\n```javascript\nasyncblock(function(flow){\n    console.time('time');\n\n    setTimeout(flow.add(), 1000);\n    setTimeout(flow.add(), 2000);\n    flow.wait(); //Wait for both setTimeouts to finish\n\n    console.timeEnd('time'); //2 seconds\n});\n```\n\n### Trapping results\n\n```javascript\nasyncblock(function(flow) {\n    //Start two parallel file reads\n    fs.readFile(path1, 'utf8', flow.set('contents1'));\n    fs.readFile(path2, 'utf8', flow.set('contents2'));\n    \n    //Print the concatenation of the results when both reads are finished\n    console.log(flow.get('contents1') + flow.get('contents2'));\n    \n    //Wait for a large number of tasks\n    for(var i = 0; i < 100; i++){\n        //Add each task in parallel with i as the key\n        fs.readFile(paths[i], 'utf8', flow.add(i));                                    \n    }\n    \n    //Wait for all the tasks to finish. Results is an object of the form {key1: value1, key2: value2, ...}\n    var results = flow.wait();\n    \n    //One-liner syntax for waiting on a single task\n    var contents = flow.sync( fs.readFile(path, 'utf8', flow.callback()) );\n    \n    //See overview & API docs for more extensive description of techniques\n});\n```\n\n### With source transformation\n\n```javascript\n//asyncblock.enableTransform() must be called before requiring modules using this syntax.\n//See overview / API for more details\n\nasyncblock(function(flow) {\n    //Start two parallel file reads\n    var contents1 = fs.readFile(path1, 'utf8').defer();\n    var contents2 = fs.readFile(path2, 'utf8').defer();\n    \n    //Print the concatenation of the results when both reads are finished\n    console.log(contents1 + contents2);\n    \n    var files = [];\n    //Wait for a large number of tasks\n    for(var i = 0; i < 100; i++){\n        //Add each task in parallel with i as the key\n        files.push( fs.readFile(paths[i], 'utf8').future() );\n    }\n    \n    //Get an array containing the file read results\n    var results = files.map(function(future){\n        return future.result;\n    });\n    \n    //One-liner syntax for waiting on a single task\n    var contents = fs.readFile(path, 'utf8').sync();\n    \n    //See overview & API docs for more extensive description of techniques\n});\n```\n\n### Error handling\n\n```javascript\nvar asyncTask = function(callback) {\n    asyncblock(function(flow) {\n        flow.errorCallback = callback; //Setting the errorCallback is the easiest way to perform error handling. If erroCallback isn't set, and an error occurs, it will be thrown instead of returned to the callback\n        \n        fs.readFile(path, 'utf8', flow.add()); //If readFile encountered an error, it would automatically get passed to the callback\n        var contents = flow.wait();\n        \n        console.log(contents); //If an error occured above, this code won't run\n    });\n});\n```\n\n### Returning results\n\n```javascript\nvar asyncTask = function(callback) {\n    asyncblock(function(flow) {\n        var contents = fs.readFile(path, 'utf8').sync(); //If readFile encountered an error, it would automatically get passed to the callback\n\n        return contents; //Return the value you want to be passed to the callback\n    }, callback); //The callback can be specified as the 2nd arg to asyncblock. It will be called with the value returned from the asyncblock as the 2nd arg.\n                  //If an error occurs, the callback will be called with the error as the first argument.\n});\n```\n\n## API\n\nSee [API documentation](https://github.com/scriby/asyncblock/blob/master/docs/api.md)\n\n## Stack traces\n\nSee [stack trace documentation](https://github.com/scriby/asyncblock/blob/master/docs/stacktrace.md)\n\n## Error handling\n\nSee [error handling documentation](https://github.com/scriby/asyncblock/blob/master/docs/errors.md)\n\n## Formatting results\n\nSee [formatting results documentation](https://github.com/scriby/asyncblock/blob/master/docs/results.md)\n\n## Parallel task rate limiting\n\nSee [maxParallel documentation](https://github.com/scriby/asyncblock/blob/master/docs/maxparallel.md)\n\n## Task timeouts\n\nSee [timeout documentation](https://github.com/scriby/asyncblock/blob/master/docs/timeout.md)\n\n## Concurrency\n\nBoth fibers, and this module, do not increase concurrency in nodejs. There is still only one thread executing at a time.\nFibers are threads which are allowed to pause and resume where they left off without blocking the event loop.\n\n## Risks\n\n* Fibers are fast, but they're not the fastest. CPU intensive tasks may prefer other solutions (you probably don't want to do CPU intensive work in node anyway...)\n* Not suitable for cases where a very large number are allocated and used for an extended period of time ([source](http://groups.google.com/group/nodejs/browse_thread/thread/ddd6e2756f1f4d8c/164f8f34d8261fdb?lnk=gst&q=fibers#164f8f34d8261fdb))\n* It requires V8 extensions, which are maintained in the node-fibers module\n     * In the worst case, if future versions of V8 break fibers support completely, a custom build of V8 would be required\n     * In the best case, V8 builds in support for coroutines directly, and asyncblock becomes based on that\n* When new versions of node (V8) come out, you may have to wait longer to upgrade if the fibers code needs to be adjusted to work with it\n\nNote that when V8 supports generators, which is currently planned, the source transformation functionality of asyncblock will be able to transform\nmost of the asyncblock code to be based on generators instead of fibers with no change to the original source. This helps\nreduce risk as it provides a path forward for asyncblock even if support for fibers became impossible in the future.\n\n## Compared to other solutions...\n\nA sample program in pure node, using the async library, and using asyncblock + fibers.\n\n### Pure node\n\n```javascript\n\nfunction example(callback){\n    var finishedCount = 0;\n    var fileContents = [];\n\n    var continuation = function(){\n        if(finishedCount < 2){\n            return;\n        }\n\n        fs.writeFile('path3', fileContents[0] + fileContents[1], function(err) {\n            if(err) {\n                throw new Error(err);\n            }\n\n            fs.readFile('path3', 'utf8', function(err, data){ \n                console.log(data);\n                console.log('all done');\n            });\n        });\n    };\n\n    fs.readFile('path1', 'utf8', function(err, data) {\n        if(err) {\n            throw new Error(err);\n        }\n\n        fnishedCount++;\n        fileContents[0] = data;\n\n        continuation();\n    });\n\n    fs.readFile('path2', 'utf8', function(err, data) {\n        if(err) {\n            throw new Error(err);\n        }\n\n        fnishedCount++;\n        fileContents[1] = data;\n\n        continuation();\n    });\n}\n```\n\n### Using async\n\n```javascript\n\nvar async = require('async');\n\nvar fileContents = [];\n\nasync.series([\n    function(callback){\n        async.parallel([\n            function(callback) {\n                fs.readFile('path1', 'utf8', callback);\n            },\n\n            function(callback) {\n                fs.readFile('path2', 'utf8', callback);\n            }\n        ],\n            function(err, results){\n                fileContents = results;                                    \n                callback(err);\n            }\n        );\n    },\n\n    function(callback) {\n        fs.writeFile('path3', fileContents[0] + fileContents[1], callback);\n    },\n\n    function(callback) {\n        fs.readFile('path3', 'utf8', function(err, data){\n            console.log(data);\n            callback(err);\n        });\n    }\n],\n    function(err) {\n        if(err) {\n            throw new Error(err);\n        }\n        \n        console.log('all done');\n    }\n);\n```\n\n### Using asyncblock + fibers\n\n```javascript\n\nvar asyncblock = require('asyncblock');\n\nasyncblock(function(flow){\n    fs.readFile('path1', 'utf8', flow.add('first'));\n    fs.readFile('path2', 'utf8', flow.add('second'));\n    \n    //Wait until done reading the first and second files, then write them to another file\n    fs.writeFile('path3', flow.wait('first') + flow.wait('second'), flow.add()); \n    flow.wait(); //Wait on all outstanding tasks\n\n    fs.readFile('path3', 'utf8', flow.add('data'));\n\n    console.log(flow.wait('data')); //Print the 3rd file's data\n    console.log('all done');\n});\n```\n\n### Using asyncblock + source transformation\n\n```javascript\n//Requires asyncblock.enableTransform to be called before requiring this module\nvar asyncblock = require('asyncblock');\n\nasyncblock(function(flow){\n    var first = fs.readFile('path1', 'utf8').defer();\n    var second = fs.readFile('path2', 'utf8').defer();\n    \n    fs.writeFile('path3', first + second).sync();\n\n    var third = fs.readFile('path3', 'utf8').defer();\n\n    console.log(third);\n    console.log('all done');\n});\n```\n\n### No prototypes were harmed in the making of this module",
  "readmeFilename": "README.md",
  "_id": "asyncblock@2.1.13",
  "dist": {
    "shasum": "2613bfa6a3312b9277fec7b8c2ab0af6592b822a"
  },
  "_from": "asyncblock@",
  "_resolved": "https://registry.npmjs.org/asyncblock/-/asyncblock-2.1.13.tgz"
}
